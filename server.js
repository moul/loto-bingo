// Generated by CoffeeScript 1.3.3
(function() {
  var Rand, app, connect, db, everyauth, express, http, io, models, mongoose, server, settings, socketio;

  process.on('uncaughtException', function(err) {
    return console.log("Caught uncaughtException: " + err.stack);
  });

  settings = require('./settings');

  if (process.env.DB_HOST) {
    settings.db.url = process.env.DB_URL;
  }

  everyauth = require('everyauth');

  connect = require('connect');

  socketio = require('socket.io');

  express = require('express');

  http = require('http');

  mongoose = require('mongoose');

  app = express();

  server = http.createServer(app);

  everyauth.twitter.consummerKey('test').consumerSecret('test2');

  app.configure(function() {
    app.set('views', "" + __dirname + "/views");
    app.set('view engine', 'jade');
    app.use(everyauth.middleware());
    app.use(express.cookieParser());
    app.use(express.session({
      secret: 'change-me'
    }));
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(app.router);
    app.use(express["static"]("" + __dirname + "/static"));
    return everyauth.helpExpress(app);
  });

  app.configure('development', function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });

  app.configure('production', function() {
    return app.use(express.errorHandler());
  });

  app.get('/private', function(req, res) {
    if (req.session.auth && req.session.auth.loggedIn) {
      return res.render('private', {
        title: 'Protected'
      });
    } else {
      console.log('The user is not logged in');
      return res.redirect('/');
    }
  });

  app.get('/about', function(req, res) {
    var context;
    context = {
      page: 'about',
      maintenance: settings.maintenance
    };
    return res.render('index', context);
  });

  Rand = (function() {

    function Rand(seed) {
      this.seed = seed;
      this.multiplier = 1664525;
      this.modulo = 4294967296;
      this.offset = 1013904223;
      if (!((this.seed != null) && (0 <= seed && seed < this.modulo))) {
        this.seed = (new Date().valueOf() * new Date().getMilliseconds()) % this.modulo;
      }
      return this;
    }

    Rand.prototype.seed = function(seed) {
      return this.seed = seed;
    };

    Rand.prototype.randn = function() {
      return this.seed = (this.multiplier * this.seed + this.offset) % this.modulo;
    };

    Rand.prototype.randf = function() {
      return this.randn() / this.modulo;
    };

    Rand.prototype.rand = function(n) {
      return Math.floor(this.randf() * n);
    };

    Rand.prototype.rand2 = function(min, max) {
      return min + this.rand(max - min);
    };

    return Rand;

  })();

  if (!settings.maintenance) {
    if (mongoose.connection.readyState !== 1 && mongoose.connection.readyState !== 2) {
      console.log("Connecting to mongoose !");
      db = mongoose.connect(settings.dburl);
    }
    models = require('./models')(mongoose, db);
    io = socketio.listen(server);
    io.on('connection', function(client) {
      client.userId = -1;
      client.json.send({
        maintenance: settings.maintenance
      });
      client.ip = client.manager.handshaken[client.id].address.address;
      client.on('request', function(req) {
        return client.ip = req.header('x-real-ip' || req.headers('x-forwarded-for' || client.ip));
      });
      client.on('error', function(err) {
        return console.log(err);
      });
      client.on('message', function(message) {
        var sess, throttled;
        sess = 'test';
        console.log('new Message !', message);
        if (message.action) {
          if (message.action === 'save-vote') {
            message.when = new Date();
            message.ip = client.ip;
            delete message.action;
            throttled = false;
            if (settings.throttle) {
              throttled = true;
              throttled = exports.doThrottle(message, client);
            }
            if ((!throttled && client.handshaked) || !settings.throttle) {
              db.save(message, function(err, res) {
                if (err) {
                  console.error(err);
                  return client.send({
                    error: err
                  });
                } else {
                  return exports.getVotes(sess, function(votes, err, res) {
                    if (err) {
                      console.error(err);
                      return client.send(err);
                    } else {
                      return io.broadcast({
                        votes: votes
                      });
                    }
                  });
                }
              });
            } else {
              client.send({
                throttled: true
              });
            }
          }
          if (message.userId != null) {
            console.log('settings userid: #{message.userId}');
            client.userId = message.userId;
          }
          if (message.bingoId != null) {
            console.log('setting bingo');
            client.bingoId = message.bingoId;
          }
          if (message.action === 'get-bingo') {
            console.log("getting bingo: " + client.bingoId + ", " + client.userId);
            exports.getBingo(client.userId, client.bingoId, function(bingo, err, res) {
              if (err) {
                console.log(err);
                return client.send(err);
              } else {
                return client.json.send({
                  bingo: bingo
                });
              }
            });
          }
          if (message.action === 'get-checks') {
            console.log('Getting checks');
            return exports.getChecks(client.bingoId, function(checks, err, res) {
              if (err) {
                console.error(err);
                return client.send(err);
              } else {
                return client.json.send({
                  checks: checks
                });
              }
            });
          }
        }
      });
      return client.on('disconnect', function() {
        return console.log('client disconnected');
      });
    });
  }

  console.log('Server side socket started');

  exports.shuffle = function(array, seed) {
    var i, j, rand, x, _i, _ref;
    rand = new Rand(seed);
    for (i = _i = 0, _ref = array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      j = parseInt(rand.randf() * i);
      x = array[i];
      array[i] = array[j];
      array[j] = x;
    }
    return array;
  };

  exports.getBingo = function(userId, bingoId, callback, res) {
    return models.Bingo.findOne({
      hash: bingoId
    }, function(err, bingo) {
      var i, len, ret, sort, _i, _j;
      ret = {};
      ret['_id'] = bingo._id;
      ret['title'] = bingo.title;
      ret['hash'] = bingo.hash;
      len = bingo.opts.length;
      sort = [];
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        sort.push(i);
      }
      if (userId) {
        exports.shuffle(sort, userId / 100000);
        console.log(sort);
      }
      ret['opts'] = [];
      for (i = _j = 0; 0 <= len ? _j < len : _j > len; i = 0 <= len ? ++_j : --_j) {
        ret['opts'].push({
          id: sort[i],
          value: bingo.opts[sort[i]]
        });
      }
      console.log(ret['opts']);
      console.log('getBingo', bingo);
      return callback(ret, err, res);
    });
  };

  exports.getPlayers = function(bingoId, callback, res) {
    var err, players;
    players = {
      0: {
        name: "Manfred"
      },
      1: {
        name: "Solvik"
      },
      5: {
        name: "Charles"
      }
    };
    err = null;
    return callback(players, err, res);
  };

  exports.getChecks = function(bingoId, callback, res) {
    var checks, err;
    checks = {
      0: [1, 2, 5, 6],
      1: [2, 4, 5, 7],
      5: [5, 1, 4, 5]
    };
    err = null;
    return callback(checks, err, res);
  };

  exports.doThrottle = function(message, client) {
    var first, throttled, _i, _len;
    throttled = true;
    throttle[client.sessionId] = throttle[client.sessionId] || 0;
    throttle[client.sessionId]++;
    if (throttle[client.sessionId] <= throttleVotes) {
      throttled = false;
    }
    if (Object.keys(throttle).length > 10000) {
      first = null;
      for (_i = 0, _len = throttle.length; _i < _len; _i++) {
        first = throttle[_i];
        break;
      }
      return delete throttle[first];
    }
  };

  app.get('/moul', function(req, res) {
    var title;
    title = 'test997';
    return models.Bingo.findOne({
      title: title
    }, function(err, bingo) {
      var i, _i;
      if (err) {
        console.log(err);
      }
      if (!(bingo != null) || !bingo) {
        bingo = new models.Bingo();
        bingo.title = title;
        bingo.hash = title;
      }
      for (i = _i = 0; _i < 16; i = ++_i) {
        bingo.opts[i] = 'test2' + i;
      }
      return bingo.save(function(err) {
        console.log(bingo);
        if (err) {
          console.log(err);
          return res.send(err);
        } else {
          return res.send('OK ' + new Date());
        }
      });
    });
  });

  app.get('/', function(req, res) {
    var context;
    context = {
      page: 'default',
      maintenance: settings.maintenance,
      title: 'Default',
      everyauth: everyauth
    };
    if (req.query != null) {
      if (req.query.bingo != null) {
        context.bingo = req.query.bingo;
      }
      if (req.query.userId != null) {
        context.userId = req.query.userId;
      }
    }
    return res.render('index', context);
  });

  server.listen(settings.port);

  console.log("Server is listening on port %d in %s mode", server.address().port, app.settings.env);

  exports.app = app;

}).call(this);
